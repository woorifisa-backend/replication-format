# 📊 MySQL 복제 포맷(SBR vs RBR) 성능 비교

## 1. 개요
MySQL의 `binlog_format` 설정에 따른 복제 메커니즘의 차이를 이해하고,  
실제 운영 환경에서 발생할 수 있는 **데이터 불일치** 및 **복제 지연(Replication Lag)** 현상을  
실험을 통해 분석합니다.

## 📊 실습 결과 요약 (Replication Test Report)

## 3️⃣ 실행 시간 비교

### 1. 테스트 환경 및 조건
- **대상 테이블:** `time_test` (약 20,000건의 레코드)  
- **부하 쿼리:**  
  ```sql
  UPDATE ... SET ... WHERE SLEEP(0.0005) = 0;
  ```
- **소스 서버 실행 시간:** 약 **17.68초**  
- **측정 지표:** `SHOW REPLICA STATUS` 내 `Seconds_Behind_Source`

---

### 2. 포맷별 지연 시간(Latency) 비교

#### 🔹 [Case 1] SBR (Statement-Based Replication)
- **지연 시간 추이:** `19s → 37s → 0s`

**현상 분석**
- 소스 서버에서 쿼리가 완료되어 로그가 전달된 시점에 이미 약 **19초의 지연** 발생  
- 레플리카가 전달받은 SQL을 실행하는 동안 실제 시간이 계속 흐르며 **지연 수치가 37초까지 증가**  
- 레플리카가 소스와 동일한 연산(`SLEEP`)을 모두 마친 후에야 지연이 `0s`로 수렴  

**결론:**  
> 소스의 연산 부하가 레플리카에 그대로 전이되어 **복제 지연(Lag)** 이 심화됨

---

#### 🔹 [Case 2] RBR (Row-Based Replication)
- **지연 시간 추이:** `19s → 1~2s → 0s (혹은 즉시 0s)`

**현상 분석**
- 소스에서 쿼리가 끝난 시점에 발생한 **기본 지연(약 19초)** 은 동일  
- 하지만 레플리카는 연산 과정을 생략하고 **최종 변경된 값만 즉시 반영**  
- 쿼리 수신 직후 지연 시간이 급격히 감소  

**결론:**  
> 연산량이 많은 작업에서는 **RBR이 SBR보다 복제 성능과 동기화 속도가 압도적으로 우수**

---

### 3. 종합 인사이트
- **SBR:** 동일 쿼리를 재실행하므로, 소스와 레플리카의 CPU/연산 자원을 이중으로 사용 → **지연 증가**  
- **RBR:** 결과값 기반 복제로 레플리카 부하 감소 → **복제 속도 향상**, 다만 변경 행이 많을 경우 **binlog 크기 증가**

**요약 결론:**  
> 본 실험을 통해 **데이터 무결성과 복제 성능 극대화를 위해 현대적인 환경에서는 RBR이 필수적**임을 확인하였음.
